#! /usr/bin/env bash
shopt | grep compat32 &>/dev/null && shopt -s compat32; CHECK_VERSION="1.2.0"
CHECK_SET_OPTS="${CHECK_SET_OPTS:-eET}" CHECK_FORMATTER="${CHECK_FORMATTER:-}"; CHECK_CONFIG="${CHECK_CONFIG:-.checkrc}" CHECK_FILE_PATTERN="${CHECK_FILE_PATTERN:-.test.sh$\|.spec.sh$}" CHECK_HELPER_PATTERN="${CHECK_HELPER_PATTERN:-testHelper.sh\|specHelper.sh}" CHECK_RANDOM="${CHECK_RANDOM:-shuf}" CHECK_SETUP_PATTERN="${CHECK_SETUP_PATTERN:-^setup\|^before}" CHECK_TEARDOWN_PATTERN="${CHECK_TEARDOWN_PATTERN:-^teardown\|^after}" CHECK_STACKTRACE="${CHECK_STACKTRACE:-}" CHECK_COLOR="${CHECK_COLOR:-true}" CHECK_SILENT="${CHECK_SILENT:-}" CHECK_VERBOSE="${VERBOSE:-}" CHECK_FILTER="${CHECK_FILTER:-}" CHECK_COLOR_TEXT="${CHECK_COLOR_TEXT:-39}" CHECK_COLOR_FAIL="${CHECK_COLOR_FAIL:-31}" CHECK_COLOR_FAIL_RESULT="${CHECK_COLOR_FAIL_RESULT:-31;1}" CHECK_COLOR_PASS="${CHECK_COLOR_PASS:-32}" CHECK_COLOR_PASS_RESULT="${CHECK_COLOR_PASS_RESULT:-32;1}" CHECK_COLOR_STACKTRACE_LINE="${CHECK_COLOR_STACKTRACE_LINE:-34}" CHECK_COLOR_STACKTRACE_CODE="${CHECK_COLOR_STACKTRACE_CODE:-33}" CHECK_COLOR_RESET="${CHECK_COLOR_RESET:-0}" CHECK_COLOR_STDOUT="${CHECK_COLOR_STDOUT:-39;2}" CHECK_COLOR_STDOUT_HEADER="${CHECK_COLOR_STDOUT_HEADER:-34;1}" CHECK_COLOR_STDERR="${CHECK_COLOR_STDERR:-39;2}" CHECK_COLOR_STDERR_HEADER="${CHECK_COLOR_STDERR_HEADER:-31;1}" CHECK_COLOR_STACKTRACE_HEADER="${CHECK_COLOR_STACKTRACE_HEADER:-33;1}" CHECK_COLOR_FILENAME="${CHECK_COLOR_FILENAME:-34}" CHECK_COLOR_TESTNAME="${CHECK_COLOR_TESTNAME:-39}"
recordCommands() { __check__return=$?; if (( $1 == 0 )) && [ "$2" != "$0" ]; then if [ -z "$CHECK_TEST_DONE" ]; then CHECK_LAST_COMMAND_INFO=("${@:1}"); fi; fi; return $__check__return; }
runTest() {
  [ -n "$CHECK_SET_OPTS" ] && [ "$CHECK_SET_OPTS" != NONE ] && set -${CHECK_SET_OPTS}; if [ -n "$CHECK_HELPER_PATTERN" ]; then while read -rd '' __check__file; do if echo "$__check__file" | grep -i "$CHECK_HELPER_PATTERN" &>/dev/null; then source "$__check__file"; fi; done < <( find "$( dirname "$CHECK_FILE" )" -maxdepth 1 -type f -print0 ); fi
  CHECK_TEST_DONE=; trap 'CHECK_LAST_COMMAND_INFO[0]=$?; CHECK_TEST_DONE=true; runAll "$CHECK_TEARDOWN_PATTERN"; declare -p CHECK_LAST_COMMAND_INFO' EXIT
  trap 'shopt -qo nounset && __check__nounset=true || __check__nounset=""; set +u; recordCommands $? "${BASH_SOURCE[0]}" "$LINENO" "${FUNCNAME[0]}" "$BASH_COMMAND"; [ -n "$__check__nounset" ] && set +u;' DEBUG;
  trap 'recordCommands $? "${BASH_SOURCE[0]}" "$LINENO" "${FUNCNAME[0]}" "$BASH_COMMAND";' DEBUG; trap : ERR
  runAll "$CHECK_SETUP_PATTERN"; $CHECK_TEST; CHECK_RESULT=$?; exit $CHECK_RESULT;
}; getColor() { [ "$CHECK_COLOR" = true ] && printf '\e[0m\e[%sm' "${!1}"; return 0; }
runAll() { if [ -z "${1:-}" ]; then return 0; fi; if CHECK_FUNCTIONS="$( declare -pF | awk '{print $3}' | grep -i "$1" 2>/dev/null )"; then for CHECK_FUNCTION in $CHECK_FUNCTIONS; do $CHECK_FUNCTION; done; fi; }
runAndDisplayOutput() {
  [ -n "$CHECK_FILTER" ] && { echo "$CHECK_TEST" | grep -i "$CHECK_FILTER" &>/dev/null || return 0; }
  CHECK_TEST_OUTPUT="$({ __check__STDERR="$({ __check__STDOUT="$( CHECK_SET_OPTS="$CHECK_SET_OPTS" "$0" --private-run "$CHECK_FILE" "$CHECK_TEST" )"; } 2>&1; declare -i CHECK_RESULT=$?; declare -p __check__STDOUT >&2; declare -p CHECK_RESULT >&2; exit $CHECK_RESULT;)"; declare -p __check__STDERR; exit 0; } 2>&1 )"
  eval "$CHECK_TEST_OUTPUT"; CHECK_LAST_COMMAND_INFO_TEXT=
  [[ "$__check__STDOUT" =~ .*(declare[[:space:]]-a[[:space:]]CHECK_LAST_COMMAND_INFO=[\']?\(.*)$ ]] && CHECK_LAST_COMMAND_INFO_TEXT="${BASH_REMATCH[1]}"
  [ -n "$CHECK_LAST_COMMAND_INFO_TEXT" ] && { eval "$CHECK_LAST_COMMAND_INFO_TEXT"; __check__STDOUT="${__check__STDOUT%"$CHECK_LAST_COMMAND_INFO_TEXT"}"; __check__STDOUT="${__check__STDOUT%$'\n'}"; }
  (( CHECK_RESULT == 0 )) && { CHECK_STATUS=PASS; CHECK_STATUS_COLOR="$CHECK_COLOR_PASS"; (( CHECK_PASSED = CHECK_PASSED + 1 )); } || { CHECK_STATUS=FAIL; CHECK_STATUS_COLOR="$CHECK_COLOR_FAIL"; (( CHECK_FAILED = CHECK_FAILED + 1 )); }
  [ "$CHECK_SILENT" != true ] && [ -z "$CHECK_FORMATTER" ] && echo -e "  $(getColor CHECK_COLOR_TEXT)[$(getColor CHECK_STATUS_COLOR)$CHECK_STATUS$(getColor CHECK_COLOR_TEXT)] $(getColor CHECK_COLOR_TESTNAME)$CHECK_TEST"
  [ -n "$__check__STDOUT" ] && [ "$CHECK_SILENT" != true ] && [ -z "$CHECK_FORMATTER" ] && { (( CHECK_RESULT != 0 )) || [ "$CHECK_VERBOSE" = true ]; } && {
    echo -e "    $(getColor CHECK_COLOR_TEXT)[$(getColor CHECK_COLOR_STDOUT_HEADER)Standard Output$(getColor CHECK_COLOR_TEXT)]$(getColor CHECK_COLOR_STDOUT)\n$( echo "$__check__STDOUT" | sed 's/^/      /' )"; }
  [ -n "$__check__STDERR" ] && [ "$CHECK_SILENT" != true ] && [ -z "$CHECK_FORMATTER" ] && { (( CHECK_RESULT != 0 )) || [ "$CHECK_VERBOSE" = true ]; } && {
    echo -e "    $(getColor CHECK_COLOR_TEXT)[$(getColor CHECK_COLOR_STDERR_HEADER)Standard Error$(getColor CHECK_COLOR_TEXT)]$(getColor CHECK_COLOR_STDERR)\n$( echo "$__check__STDERR" | sed 's/^/      /' )"; };
  [ -n "${CHECK_LAST_COMMAND_INFO-}" ] && (( ${#CHECK_LAST_COMMAND_INFO[@]} > 0 )) && [ -n "${CHECK_LAST_COMMAND_INFO[1]}" ] && [ -f "${CHECK_LAST_COMMAND_INFO[1]}" ] && [ "$CHECK_SILENT" != true ] && [ -z "$CHECK_FORMATTER" ] && { [ "$CHECK_STACKTRACE" = true ] || (( CHECK_RESULT != 0 )); } && {
    echo -e "    $(getColor CHECK_COLOR_TEXT)[$(getColor CHECK_COLOR_STACKTRACE_HEADER)Stacktrace$(getColor CHECK_COLOR_TEXT)]\n      $(getColor CHECK_COLOR_STACKTRACE_LINE)${CHECK_LAST_COMMAND_INFO[1]}$(getColor CHECK_COLOR_TEXT):$(getColor CHECK_COLOR_STACKTRACE_LINE)${CHECK_LAST_COMMAND_INFO[2]} ${CHECK_LAST_COMMAND_INFO[3]}\n$(getColor CHECK_COLOR_STACKTRACE_CODE)$( sed "${CHECK_LAST_COMMAND_INFO[2]}q;d" "${CHECK_LAST_COMMAND_INFO[1]}" | sed "s/^ *//g" | sed "s/^/        /" )";
  }; CHECK_STDOUT="$__check__STDOUT"; CHECK_STDERR="$__check__STDERR"
  [ -n "${CHECK_LAST_COMMAND_INFO-}" ] && { CHECK_LAST_COMMAND=("${CHECK_LAST_COMMAND_INFO[2]}"); CHECK_LAST_EXITCODE="${CHECK_LAST_COMMAND_INFO[0]}"; CHECK_LAST_SOURCE="${CHECK_LAST_COMMAND_INFO[1]}"; CHECK_LAST_LINENO="${CHECK_LAST_COMMAND_INFO[2]}"; CHECK_LAST_FUNCNAME="${CHECK_LAST_COMMAND_INFO[3]}"; CHECK_LAST_COMMAND="${CHECK_LAST_COMMAND_INFO[4]}"; if [ -n "${CHECK_LAST_COMMAND_INFO[1]}" ] && [ -f "${CHECK_LAST_COMMAND_INFO[1]}" ]; then CHECK_LAST_SOURCECODE="$( sed "${CHECK_LAST_COMMAND_INFO[2]}q;d" "${CHECK_LAST_COMMAND_INFO[1]}" | sed "s/^ *//g" )"; fi; } || CHECK_LAST_COMMAND=(); return 0
}
(( $# > 0 )) && { case "$1" in -h|--help) echo "${0##*/}: <test file> <test file> ..."; exit 0 ;; --version) echo "check version $CHECK_VERSION"; exit 0 ;;
  -l|--list) shift; CHECK_FILE="$1"; shift; [ -f "$CHECK_FILE" ] || exit 1; source "$CHECK_FILE" && declare -pF | awk '{print $3}' | grep -i "${CHECK_TEST_PATTERN:-^test\|^spec\|^@test\|^@spec}" 2>/dev/null; exit 0 ;;
  --private-run) shift; CHECK_FILE="$1"; shift; CHECK_TEST="$1"; shift; source "$CHECK_FILE" && runTest; exit $? ;;
esac; }
CHECK_PASSED=0; CHECK_FAILED=0; CHECK_FILES=(); CHECK_DIRS=(); while (( $# > 0 )); do case "$1" in
  -v|--verbose) CHECK_VERBOSE=true; shift ;; -q|--quiet) CHECK_SILENT=true; shift ;; -f|--filter) CHECK_FILTER="$2"; shift 2 ;; -s|--set) CHECK_SET_OPTS="$2"; shift 2 ;; --no-set-e) CHECK_SET_OPTS=T; shift ;; --no-set) CHECK_SET_OPTS=NONE; shift ;; --test-pattern) CHECK_TEST_PATTERN="$2"; shift 2 ;; --setup-pattern) CHECK_SETUP_PATTERN="$2"; shift 2 ;; --no-random) CHECK_RANDOM="grep ."; shift ;;
  --color) CHECK_COLOR=true; shift ;; --no-color) CHECK_COLOR=false; shift ;; -c|--config) CHECK_CONFIG="$2"; shift 2 ;; --formatter) CHECK_FORMATTER="$2"; shift 2 ;; --file-pattern) CHECK_FILE_PATTERN="$2"; shift 2; ;; --teardown-pattern) CHECK_TEARDOWN_PATTERN="$2"; shift 2 ;; -r|--random) CHECK_RANDOM=shuf; shift ;;
  *) [ -f "$1" ] && { CHECK_FILES+=("$1"); shift; } || { [ -d "$1" ] && { CHECK_DIRS+=("$1"); shift; } || { echo "${0##*/}: unknown argument '$*'" >&2; exit 1; }; }
esac; done; [ -f "$CHECK_CONFIG" ] && source "$CHECK_CONFIG"; [ -f "$CHECK_FORMATTER" ] && source "$CHECK_FORMATTER";
(( ${#CHECK_DIRS[@]} > 0 )) && { for CHECK_DIR in "${CHECK_DIRS[@]}"; do while read -rd '' CHECK_FILE; do echo "$CHECK_FILE" | grep "$CHECK_FILE_PATTERN" &>/dev/null && CHECK_FILES+=("$CHECK_FILE"); done < <( find "$CHECK_DIR" -type f -name "*${CHECK_FILE_EXT:-.sh}" -print0 ); done; }
(( ${#CHECK_FILES[@]} == 0 )) && { while read -rd '' CHECK_FILE; do echo "$CHECK_FILE" | grep -i "$CHECK_FILE_PATTERN" &>/dev/null && CHECK_FILES+=("$CHECK_FILE"); done < <( find . -type f -name "*${CHECK_FILE_EXT:-.sh}" -print0 ); }
(( ${#CHECK_FILES[@]} == 0 )) && { echo -e "${0##*/}: No test files provided to run.\nUsage: ${0##*/} <test file> <test file>"; exit 0; }
if declare -F beforeSuite &>/dev/null; then beforeSuite; fi; CHECK_RANDOM_FILES=(); while read -r CHECK_FILE; do CHECK_RANDOM_FILES+=("$CHECK_FILE") ;done < <( printf '%s\n' "${CHECK_FILES[@]}" | $CHECK_RANDOM ); CHECK_FILES=("${CHECK_RANDOM_FILES[@]}")
for CHECK_FILE in "${CHECK_FILES[@]}"; do CHECK_DIR="$(dirname "$CHECK_FILE")"; if declare -F beforeTestFile &>/dev/null; then beforeTestFile; fi
  CHECK_TESTS="$( "$0" --list "$CHECK_FILE" | $CHECK_RANDOM )" || { echo "${0##*/}: failed to find tests in file: '$CHECK_FILE'" >&2; continue; }
  [ "$CHECK_SILENT" != true ] && [ -z "$CHECK_FORMATTER" ] && echo -e "$(getColor CHECK_COLOR_TEXT)[$(getColor CHECK_COLOR_FILENAME)$CHECK_FILE$(getColor CHECK_COLOR_TEXT)]"; for CHECK_TEST in $CHECK_TESTS; do if declare -F beforeTest &>/dev/null; then beforeTest; fi; runAndDisplayOutput; if declare -F afterTest &>/dev/null; then afterTest; fi; done; [ "$CHECK_SILENT" != true ] && [ -z "$CHECK_FORMATTER" ] && echo;
  if declare -F afterTestFile &>/dev/null; then afterTestFile; fi
done; if declare -F afterSuite &>/dev/null; then afterSuite; fi
CHECK_RESULT=""; (( CHECK_FAILED > 0 )) && { CHECK_RESULT="$(getColor CHECK_COLOR_FAIL_RESULT)$CHECK_FAILED Test(s) Failed"; (( CHECK_PASSED > 0 )) && CHECK_RESULT+=", $CHECK_PASSED Test(s) Passed" || CHECK_RESULT+=""; }
(( CHECK_FAILED == 0 )) && { [ "$CHECK_SILENT" != true ] && [ -z "$CHECK_FORMATTER" ] && echo -e "$(getColor CHECK_COLOR_PASS_RESULT)$CHECK_PASSED Test(s) Passed\e[0m"; exit 0; } || { [ "$CHECK_SILENT" != true ] && [ -z "$CHECK_FORMATTER" ] && echo -e "$CHECK_RESULT\e[0m" >&2; exit 1; }