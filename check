#! /usr/bin/env bash
shopt | grep compat32 &>/dev/null && shopt -s compat32; CHECK_VERSION="1.2.0"
CHECK_SET_OPTS="${CHECK_SET_OPTS:-eET}" CHECK_CUSTOM_FORMATTER="${CHECK_CUSTOM_FORMATTER:-false}"; CHECK_CONFIG="${CHECK_CONFIG:-.checkrc}" CHECK_RANDOM="${CHECK_RANDOM:-shuf}" CHECK_SETUP_PATTERN="${CHECK_SETUP_PATTERN:-^setup\|^before}" CHECK_TEARDOWN_PATTERN="${CHECK_TEARDOWN_PATTERN:-^teardown\|^after}" CHECK_COLOR="${CHECK_COLOR:-true}" CHECK_SILENT="${CHECK_SILENT:-}" CHECK_VERBOSE="${VERBOSE:-}" CHECK_FILTER="${CHECK_FILTER:-}" CHECK_COLOR_TEXT="${CHECK_COLOR_TEXT:-39}" CHECK_COLOR_FAIL="${CHECK_COLOR_FAIL:-31}" CHECK_COLOR_FAIL_RESULT="${CHECK_COLOR_FAIL_RESULT:-31;1}" CHECK_COLOR_PASS="${CHECK_COLOR_PASS:-32}" CHECK_COLOR_PASS_RESULT="${CHECK_COLOR_PASS_RESULT:-32;1}" CHECK_COLOR_NEUTRAL="${CHECK_COLOR_NEUTRAL:-34}" CHECK_COLOR_CODE="${CHECK_COLOR_CODE:-33}" CHECK_COLOR_RESET="${CHECK_COLOR_RESET:-0}" CHECK_COLOR_STDOUT="${CHECK_COLOR_STDOUT:-39;2}" CHECK_COLOR_STDOUT_HEADER="${CHECK_COLOR_STDOUT_HEADER:-34;1}" CHECK_COLOR_STDERR="${CHECK_COLOR_STDERR:-39;2}" CHECK_COLOR_STDERR_HEADER="${CHECK_COLOR_STDERR_HEADER:-31;1}" CHECK_COLOR_STACKTRACE_HEADER="${CHECK_COLOR_STACKTRACE_HEADER:-33;1}" CHECK_COLOR_FILENAME="${CHECK_COLOR_FILENAME:-34}"
recordCommands() { __check__return=$?; if (( $1 == 0 )) && [ "$2" != "$0" ]; then CHECK_LAST_COMMAND_INFO=("${@:1}"); fi; return $__check__return; }
runTest() {
  [ -n "$CHECK_SET_OPTS" ] && [ "$CHECK_SET_OPTS" != NONE ] && set -${CHECK_SET_OPTS}
  CHECK_TEST_EXITED=; trap 'if [ -z "$CHECK_TEST_EXITED" ]; then { __check__exitCode=$?; if declare -p CHECK_LAST_COMMAND_INFO &>/dev/null; then CHECK_LAST_COMMAND_INFO[0]=$__check__exitCode; declare -p CHECK_LAST_COMMAND_INFO; fi; runAll "$CHECK_TEARDOWN_PATTERN"; }; fi' EXIT RETURN
  trap 'shopt -qo nounset && __check__nounset=true || __check__nounset=""; set +u; recordCommands $? "${BASH_SOURCE[0]}" "$LINENO" "${FUNCNAME[0]}" "$BASH_COMMAND"; [ -n "$__check__nounset" ] && set +u;' DEBUG;
  trap 'recordCommands $? "${BASH_SOURCE[0]}" "$LINENO" "${FUNCNAME[0]}" "$BASH_COMMAND";' DEBUG; trap : ERR
  runAll "$CHECK_SETUP_PATTERN"; $CHECK_TEST; CHECK_RESULT=$?; trap - EXIT RETURN ERR DEBUG; exit $CHECK_RESULT;
}; getColor() { [ "$CHECK_COLOR" = true ] && printf '\e[%sm' "${!1}"; return 0; }
runAll() { if [ -z "${1:-}" ]; then return 0; fi; if CHECK_FUNCTIONS="$( declare -pF | awk '{print $3}' | grep -i "$1" 2>/dev/null )"; then for CHECK_FUNCTION in $CHECK_FUNCTIONS; do $CHECK_FUNCTION; done; fi; }
runAndDisplayOutput() {
  [ -n "$CHECK_FILTER" ] && { echo "$CHECK_TEST" | grep "$CHECK_FILTER" &>/dev/null || return 0; }
  CHECK_TEST_OUTPUT="$({ CHECK_STDERR="$({ CHECK_STDOUT="$( CHECK_SET_OPTS="$CHECK_SET_OPTS" "$0" --private-run "$CHECK_FILE" "$CHECK_TEST" )"; } 2>&1; declare -i CHECK_RESULT=$?; declare -p CHECK_STDOUT >&2; declare -p CHECK_RESULT >&2; exit $CHECK_RESULT;)"; declare -p CHECK_STDERR; exit 0; } 2>&1 )"
  eval "$CHECK_TEST_OUTPUT"; CHECK_LAST_COMMAND_INFO_TEXT=
  [[ "$CHECK_STDOUT" =~ .*(declare[[:space:]]-a[[:space:]]CHECK_LAST_COMMAND_INFO=[\']?\(.*)$ ]] && CHECK_LAST_COMMAND_INFO_TEXT="${BASH_REMATCH[1]}"
  [ -n "$CHECK_LAST_COMMAND_INFO_TEXT" ] && { eval "$CHECK_LAST_COMMAND_INFO_TEXT"; CHECK_STDOUT="${CHECK_STDOUT%"$CHECK_LAST_COMMAND_INFO_TEXT"}"; CHECK_STDOUT="${CHECK_STDOUT%$'\n'}"; }
  (( CHECK_RESULT == 0 )) && { CHECK_STATUS=PASS; CHECK_STATUS_COLOR="$CHECK_COLOR_PASS"; (( CHECK_PASSED = CHECK_PASSED + 1 )); } || { CHECK_STATUS=FAIL; CHECK_STATUS_COLOR="$CHECK_COLOR_FAIL"; (( CHECK_FAILED = CHECK_FAILED + 1 )); }
  [ "$CHECK_SILENT" != true ] && [ "$CHECK_CUSTOM_FORMATTER" != true ] && echo -e "  $(getColor CHECK_COLOR_TEXT)[$(getColor CHECK_STATUS_COLOR)$CHECK_STATUS$(getColor CHECK_COLOR_TEXT)] $CHECK_TEST"
  [ -n "$CHECK_STDOUT" ] && [ "$CHECK_SILENT" != true ] && [ "$CHECK_CUSTOM_FORMATTER" != true ] && { (( CHECK_RESULT != 0 )) || [ "$CHECK_VERBOSE" = true ]; } && {
    echo -e "    $(getColor CHECK_COLOR_TEXT)[$(getColor CHECK_COLOR_STDOUT_HEADER)Standard Output$(getColor CHECK_COLOR_RESET)$(getColor CHECK_COLOR_TEXT)]$(getColor CHECK_COLOR_STDOUT)\n$( echo "$CHECK_STDOUT" | sed 's/^/      /' )$(getColor CHECK_COLOR_RESET)"; }
  [ -n "$CHECK_STDERR" ] && [ "$CHECK_SILENT" != true ] && [ "$CHECK_CUSTOM_FORMATTER" != true ] && { (( CHECK_RESULT != 0 )) || [ "$CHECK_VERBOSE" = true ]; } && {
    echo -e "    $(getColor CHECK_COLOR_TEXT)[$(getColor CHECK_COLOR_STDERR_HEADER)Standard Error$(getColor CHECK_COLOR_RESET)$(getColor CHECK_COLOR_TEXT)]$(getColor CHECK_COLOR_STDERR)\n$( echo "$CHECK_STDERR" | sed 's/^/      /' )$(getColor CHECK_COLOR_RESET)"; };
  [ -n "${CHECK_LAST_COMMAND_INFO-}" ] && (( ${#CHECK_LAST_COMMAND_INFO[@]} > 0 )) && [ "$CHECK_SILENT" != true ] && [ "$CHECK_CUSTOM_FORMATTER" != true ] && (( CHECK_RESULT != 0 )) && {
    echo -e "    $(getColor CHECK_COLOR_TEXT)[$(getColor CHECK_COLOR_STACKTRACE_HEADER)Stacktrace$(getColor CHECK_COLOR_RESET)$(getColor CHECK_COLOR_TEXT)]\n      $(getColor CHECK_COLOR_NEUTRAL)${CHECK_LAST_COMMAND_INFO[1]}$(getColor CHECK_COLOR_TEXT):$(getColor CHECK_COLOR_NEUTRAL)${CHECK_LAST_COMMAND_INFO[2]} ${CHECK_LAST_COMMAND_INFO[3]}\n$(getColor CHECK_COLOR_CODE)$( sed "${CHECK_LAST_COMMAND_INFO[2]}q;d" "${CHECK_LAST_COMMAND_INFO[1]}" | sed "s/^ *//g" | sed "s/^/        /" )$(getColor CHECK_COLOR_RESET)";
  };
  [ -n "${CHECK_LAST_COMMAND_INFO-}" ] && { CHECK_LAST_COMMAND=("${CHECK_LAST_COMMAND_INFO[2]}"); CHECK_LAST_EXITCODE="${CHECK_LAST_COMMAND_INFO[0]}"; CHECK_LAST_SOURCE="${CHECK_LAST_COMMAND_INFO[1]}"; CHECK_LAST_LINENO="${CHECK_LAST_COMMAND_INFO[2]}"; CHECK_LAST_FUNCNAME="${CHECK_LAST_COMMAND_INFO[3]}"; CHECK_LAST_COMMAND="${CHECK_LAST_COMMAND_INFO[4]}"; CHECK_LAST_CODE="$( sed "${CHECK_LAST_COMMAND_INFO[2]}q;d" "${CHECK_LAST_COMMAND_INFO[1]}" | sed "s/^ *//g" )"; } || CHECK_LAST_COMMAND=(); return 0
}
(( $# > 0 )) && { case "$1" in -h|--help) echo "${0##*/}: <test file> <test file> ..."; exit 0 ;; --version) echo "check version $CHECK_VERSION"; exit 0 ;;
  --private-list) shift; CHECK_FILE="$1"; shift; source "$CHECK_FILE" && declare -pF | awk '{print $3}' | grep -i "${CHECK_TEST_PATTERN:-^test\|^spec\|^@test\|^@spec}" 2>/dev/null; exit 0 ;;
  --private-run) shift; CHECK_FILE="$1"; shift; CHECK_TEST="$1"; shift; source "$CHECK_FILE" && runTest; exit $? ;;
esac; }
CHECK_PASSED=0; CHECK_FAILED=0; CHECK_FILES=(); CHECK_DIRS=(); while (( $# > 0 )); do case "$1" in
  -v|--verbose) CHECK_VERBOSE=true; shift ;; -q|--quiet) CHECK_SILENT=true; shift ;; -f|--filter) CHECK_FILTER="$2"; shift 2 ;; -s|--set) CHECK_SET_OPTS="$2"; shift 2 ;; --no-set-e) CHECK_SET_OPTS=T; shift ;; --no-set) CHECK_SET_OPTS=NONE; shift ;; --test-pattern) CHECK_TEST_PATTERN="$2"; shift 2 ;; --setup-pattern) CHECK_SETUP_PATTERN="$2"; shift 2 ;; --no-random) CHECK_RANDOM="grep ."; shift ;;
  --color) CHECK_COLOR=true; shift ;; --no-color) CHECK_COLOR=false; shift ;; -c|--config) CHECK_CONFIG="$2"; shift 2 ;; --formatter) CHECK_CUSTOM_FORMATTER=true; source "$2"; shift 2 ;; --file-pattern) CHECK_FILE_PATTERN="$2"; shift 2; ;; --teardown-pattern) CHECK_TEARDOWN_PATTERN="$2"; shift 2 ;; -r|--random) CHECK_RANDOM=shuf; shift ;;
  *) [ -f "$1" ] && { CHECK_FILES+=("$1"); shift; } || { [ -d "$1" ] && { CHECK_DIRS+=("$1"); shift; } || { echo "${0##*/}: unknown argument '$*'" >&2; exit 1; }; }
esac; done
(( ${#CHECK_DIRS[@]} > 0 )) && { for CHECK_DIR in "${CHECK_DIRS[@]}"; do while read -rd '' CHECK_FILE; do echo "$CHECK_FILE" | grep "${CHECK_FILE_PATTERN:-.test.sh$\|.spec.sh$}" &>/dev/null && CHECK_FILES+=("$CHECK_FILE"); done < <( find "$CHECK_DIR" -type f -name "*${CHECK_FILE_EXT:-.sh}" -print0 ); done; }
(( ${#CHECK_FILES[@]} == 0 )) && { while read -rd '' CHECK_FILE; do echo "$CHECK_FILE" | grep -i "${CHECK_FILE_PATTERN:-.test.sh$\|.spec.sh$}" &>/dev/null && CHECK_FILES+=("$CHECK_FILE"); done < <( find . -type f -name "*${CHECK_FILE_EXT:-.sh}" -print0 ); }
(( ${#CHECK_FILES[@]} == 0 )) && { echo -e "${0##*/}: No test files provided to run.\nUsage: ${0##*/} <test file> <test file>"; exit 0; }
[ -f "$CHECK_CONFIG" ] && source "$CHECK_CONFIG"; if declare -F beforeSuite &>/dev/null; then beforeSuite; fi; CHECK_RANDOM_FILES=(); while read -r CHECK_FILE; do CHECK_RANDOM_FILES+=("$CHECK_FILE") ;done < <( printf '%s\n' "${CHECK_FILES[@]}" | $CHECK_RANDOM ); CHECK_FILES=("${CHECK_RANDOM_FILES[@]}")
for CHECK_FILE in "${CHECK_FILES[@]}"; do if declare -F beforeTestFile &>/dev/null; then beforeTestFile; fi
  CHECK_TESTS="$( "$0" --private-list "$CHECK_FILE" | $CHECK_RANDOM )" || { echo "${0##*/}: failed to find tests in file: '$CHECK_FILE'" >&2; continue; }
  [ "$CHECK_SILENT" != true ] && [ "$CHECK_CUSTOM_FORMATTER" != true ] && echo -e "$(getColor CHECK_COLOR_TEXT)[$(getColor CHECK_COLOR_FILENAME)$CHECK_FILE$(getColor CHECK_COLOR_RESET)$(getColor CHECK_COLOR_TEXT)]"; for CHECK_TEST in $CHECK_TESTS; do if declare -F beforeTest &>/dev/null; then beforeTest; fi; runAndDisplayOutput; if declare -F afterTest &>/dev/null; then afterTest; fi; done; [ "$CHECK_SILENT" != true ] && [ "$CHECK_CUSTOM_FORMATTER" != true ] && echo;
  if declare -F afterTestFile &>/dev/null; then afterTestFile; fi
done; if declare -F afterSuite &>/dev/null; then afterSuite; fi
CHECK_RESULT="$(getColor CHECK_COLOR_RESET)"; (( CHECK_FAILED > 0 )) && { CHECK_RESULT="$(getColor CHECK_COLOR_FAIL_RESULT)$CHECK_FAILED Test(s) Failed"; (( CHECK_PASSED > 0 )) && CHECK_RESULT+=", $CHECK_PASSED Test(s) Passed$(getColor CHECK_COLOR_RESET)" || CHECK_RESULT+="$(getColor CHECK_COLOR_RESET)"; }
(( CHECK_FAILED == 0 )) && { [ "$CHECK_SILENT" != true ] && [ "$CHECK_CUSTOM_FORMATTER" != true ] && echo -e "$(getColor CHECK_COLOR_PASS_RESULT)$CHECK_PASSED Test(s) Passed$(getColor CHECK_COLOR_RESET)"; exit 0; } || { [ "$CHECK_SILENT" != true ] && [ "$CHECK_CUSTOM_FORMATTER" != true ] && echo -e "$CHECK_RESULT" >&2; exit 1; }